## О чем речь:
Будем писать торгового робота на python.
Для начала работа над торговым роботом нужно следующее:

- компьютер, с установленным интерпретатором Python3.
- PyCharm в качестве IDE.

## part_1 - Текстовая версия
Добрый день.
Сегодня, я буду писать торгового бота на языке python.
Робот будет работать следующим образом:
- покупать по цене ниже рынка;
- продавать по цене выше цены покупки;

На примере доллара это будет выглядеть примерно так.
Пусть текущая цена доллара - 71 рубль.
Тогда робот будет покупать доллар по 70, а продавать по 75.

Хочу заметить, что продавать робот может только то, что купил ранее, или, говоря биржевым языком, только тогда, когда позиция больше нуля.
Позицию бота, то есть количество долларов в виртуальном кошельке, я буду хранить в переменной position_size.
Тогда логика для покупки и продажи, записанная в виде кода, будет выглядеть так:
    
![img.png](img/img.png)

Если позиция больше нуля, то есть, если у робота есть доллары, он их продает.
В ином случае, то есть когда позиция равна или меньше нуля, робот будет покупать доллар.
Чтобы position_size не подчеркивалась красным, необходимо определить переменную с таким название и задать ей значение. 
Для начала пусть она будет равна нулю. 
Запускаем код, и видим, что робот хочет купить доллары:

![img_2.png](img/img_2.png)

Действительно, при отсутствии долларов, бот должен их покупать.
Попробуем изменить значение position_size на, скажем, 5 и запустим код снова.

![img_3.png](img/img_3.png)

Действительно, когда у бота есть доллары, он должен их продавать.

Базовый сценарий работы робота определен и даже протестирован. Однако практической пользы от него нет. 
Дело в том, что цены, по которым робот будет покупать и продавать доллары, указаны в абсолютном виде.
Вне зависимости от того, какая цена доллара на бирже, робот будет пытаться купить доллар по 70, а продать по 75.
Если цена ушла вверх и доллар стоит, к примеру, 90 рублей, то купить его за 70 уже не получится.

Цена покупки должна быть чуть ниже цены рынка, то есть чуть меньше цены последней сделки.
Рыночная цена, пусть она будет равна 71 рубль, будет храниться в переменной last_price.
Цена покупки, назовем ее buy_price, будет равна рыночной цене (last_price) минус какое-то значение.
Это значение может меняться в зависимости от разных факторов. Поэтому его стоит вынести в отдельную переменную.
Назовем ее step и сделаем равной 1.

Теперь, вместо абсолютного значения цены покупки, будем использовать переменную buy_price.
Робот покупает доллары, когда позиция меньше или равна 0. Поэтому поменяем значение position_size на 0 и запустим код.
Видим, что робот хочет купить доллары по 70. 

![img_4.png](img/img_4.png)

Представим, что доллар вырос до 90. Изменим last_price, укажем 90.
Запустим код. Робот хочет купить доллары, но уже по 89.

![img_5.png](img/img_5.png)

Подобную операцию нужно сделать с ценой продажи. Для этого нам нужно взять цену открытия позиции - position_price
(пока она будет равна buy_price) и прибавить значение желаемой прибыли (маржу из переменной margin).
Теперь можем использовать sell_price вместо абсолютной цены продажи.
Делаем позицию положительную и смотрим цену, по которой робот будет продавать доллары.

![img_7.png](img/img_7.png)

Давайте немного потестируем робота. 
Значения переменных last_price, position_size и position_price в будущем, робот будет получать от биржи. 
Сейчас, для тестирования, мы сделаем функции заглушки, которые будут возвращать случайные значения.
Выведем значение переменных в консоль и проверим, корректно ли отработал алгоритм.

![img_8.png](img/img_8.png)

Итак, у нас есть доллары, купленные по 71 рублю. Продавать мы их будет по 76 рублей - цена покупки + маржа (71 + 5)

Алгоритм работает так, как ожидается, но выполняет действие только раз. Нужно, чтобы он работал постоянно.
Добавим бесконечный цикл и задержку между итерациями. Поставим 15 секунд.

![img_9.png](img/img_9.png)

Теперь робот работает без остановки. В консоль, каждые 15 секунд, выводятся случайные значения цен из функция-заглушек, 
а так же цены и направление операции. Можно понаблюдать и проверить, правильно ли работает алгоритм. 
Для остановки робота, нужно нажать на красный квадратик, отмеченный на скриншоте красной стрелочкой. 

Казалось бы все хорошо. Алгоритм работает правильно. Однако он не учитывает один момент. 
Дело в том, что каждые 15 секунд робот выставляет заявку на покупку или продажу долларов. 
Но выставленная заявка совсем не означает, что доллары будут куплены или проданы.
Вот пример:
Позиция робота равна 1. Цена позиции: 70 рублей. Цена последней сделки 71 рубль.
Робот выставит заявку на продажу одного доллара по цене 75 рублей. Но при текущей рыночной цене в 71 рубль, за 75 рублей доллары никто не купит.
Через 15 секунд, робот выставит еще одну заявку на продажу одного доллара по цене 75 рублей.
Таким образом, через минуту, робот будет продавать уже 4 доллара по цене 75 рублей, а через 5 минут, уже 20.
И это при том, что позиция у робота равна единице.

Чтобы избежать данной ситуации, необходимо проверять наличие открытых заявок у робота. 
То есть, если в предыдущем шаге цикла робот выставил заявку на продажу, но никто не купил доллар, и эта заявка осталась открытой, 
то на последующих итерациях заявку выставлять не нужно.
То же нужно сделать и для покупки.

Воспользуемся еще одной функцией-заглушкой и будем записывать выданный ею результат в переменную open_order.
Переменная open_order может случайным образом принимать значения от 0 до 2.
0 - будет означать, что открытых заявок нет. В этом случае робот будет выставлять заявки. 
Если open_order больше 0, значит открытые заявки есть, и выставление новых не требуется.
Давайте проверим, как это работает.

![img_10.png](img/img_10.png)

Теперь робот будет выставлять заявки на продажу или покупку только тогда, когда нужно.

Всё. Основной алгоритм робота написан и протестирован. 
Немного приведем его в порядок, чтобы не трогать его в дальнейшем и не сломать.
Вынесем задержку в переменную. Сделаем функции для создания заявок. 
Осталось только функции-заглушки заменить на рабочие и можно зарабатывать деньги :)
